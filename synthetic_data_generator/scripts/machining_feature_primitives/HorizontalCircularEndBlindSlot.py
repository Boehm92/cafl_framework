import math

import numpy as np
import madcad as mdc


class HorizontalCircularEndBlindSlot:
    def __init__(self, limit):
        self.dir = np.random.choice(["direction_1", "direction_2", "direction_3", "direction_4", "direction_5",
                                     "direction_6", "direction_7", "direction_8", "direction_9", "direction_10",
                                     "direction_11", "direction_12", "direction_13", "direction_14", "direction_15",
                                     "direction_16", "direction_17", "direction_18", "direction_19", "direction_20",
                                     "direction_21", "direction_22",  "direction_23", "direction_24"])
        self.limit = limit
        self.width = np.random.uniform(1, (4 * self.limit))
        self.length = np.random.uniform(1, (9 * self.limit) - (2 * self.width))
        self.radius = (self.width * math.sin(math.radians(45)))
        self.depth = np.random.uniform(1, 9)

        self.basic_start_point = 5
        self.negative_start_point = -0.0002
        self.positive_start_point = 10.0002

        self.circular_vectors = {
            # top side front edge
            "direction_1": {
                "vector_A": mdc.vec3(self.basic_start_point, self.negative_start_point + self.width,
                                     self.positive_start_point),
                "vector_B": mdc.vec3((self.basic_start_point - (self.length / 2)),
                                     self.negative_start_point + self.width,
                                     self.positive_start_point),
                "vector_C": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point + self.radius,
                                     self.positive_start_point),
                "vector_D": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point,
                                     self.positive_start_point),
                "vector_E": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point,
                                     self.positive_start_point),
                "vector_F": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point + self.radius,
                                     self.positive_start_point),
                "vector_G": mdc.vec3((self.basic_start_point + (self.length / 2)),
                                     self.negative_start_point + self.width,
                                     self.positive_start_point)
            },
            # top side back edge
            "direction_2": {
                "vector_A": mdc.vec3(self.basic_start_point, self.positive_start_point - self.width,
                                     self.positive_start_point),
                "vector_B": mdc.vec3((self.basic_start_point + (self.length / 2)),
                                     self.positive_start_point - self.width,
                                     self.positive_start_point),
                "vector_C": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point - self.radius,
                                     self.positive_start_point),
                "vector_D": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point,
                                     self.positive_start_point),
                "vector_E": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point,
                                     self.positive_start_point),
                "vector_F": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point - self.radius,
                                     self.positive_start_point),
                "vector_G": mdc.vec3((self.basic_start_point - (self.length / 2)),
                                     self.positive_start_point - self.width,
                                     self.positive_start_point)
            },
            # top side left edge
            "direction_3": {
                "vector_A": mdc.vec3(self.width, self.basic_start_point, self.positive_start_point),
                "vector_B": mdc.vec3(self.width, (self.basic_start_point + (self.length / 2)),
                                     self.positive_start_point),
                "vector_C": mdc.vec3(self.radius, (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point),
                "vector_D": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point),
                "vector_E": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point),
                "vector_F": mdc.vec3(self.radius, (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point),
                "vector_G": mdc.vec3(self.width, (self.basic_start_point - (self.length / 2)),
                                     self.positive_start_point)
            },
            # top side right edge
            "direction_4": {
                "vector_A": mdc.vec3(self.positive_start_point - self.width, self.basic_start_point,
                                     self.positive_start_point),
                "vector_B": mdc.vec3(self.positive_start_point - self.width,
                                     (self.basic_start_point - (self.length / 2)),
                                     self.positive_start_point),
                "vector_C": mdc.vec3(self.positive_start_point - self.radius,
                                     (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point),
                "vector_D": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point),
                "vector_E": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point),
                "vector_F": mdc.vec3(self.positive_start_point - self.radius,
                                     (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point),
                "vector_G": mdc.vec3(self.positive_start_point - self.width,
                                     (self.basic_start_point + (self.length / 2)),
                                     self.positive_start_point)
            },
            # bottom side left edge
            "direction_5": {
                "vector_A": mdc.vec3(self.width, self.basic_start_point, self.negative_start_point),
                "vector_B": mdc.vec3(self.width, (self.basic_start_point - (self.length / 2)),
                                     self.negative_start_point),
                "vector_C": mdc.vec3(self.radius, (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point),
                "vector_D": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point),
                "vector_E": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point),
                "vector_F": mdc.vec3(self.radius, (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point),
                "vector_G": mdc.vec3(self.width, (self.basic_start_point + (self.length / 2)),
                                     self.negative_start_point)
            },
            # bottom side back edge
            "direction_6": {
                "vector_A": mdc.vec3(self.basic_start_point, self.positive_start_point - self.width,
                                     self.negative_start_point),
                "vector_B": mdc.vec3((self.basic_start_point - (self.length / 2)),
                                     self.positive_start_point - self.width,
                                     self.negative_start_point),
                "vector_C": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point - self.radius,
                                     self.negative_start_point),
                "vector_D": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point,
                                     self.negative_start_point),
                "vector_E": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point,
                                     self.negative_start_point),
                "vector_F": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point - self.radius,
                                     self.negative_start_point),
                "vector_G": mdc.vec3((self.basic_start_point + (self.length / 2)),
                                     self.positive_start_point - self.width,
                                     self.negative_start_point)
            },
            # bottom side left edge
            "direction_7": {
                "vector_A": mdc.vec3(self.width, self.basic_start_point, self.negative_start_point),
                "vector_B": mdc.vec3(self.width, (self.basic_start_point - (self.length / 2)),
                                     self.negative_start_point),
                "vector_C": mdc.vec3(self.radius, (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point),
                "vector_D": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point),
                "vector_E": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point),
                "vector_F": mdc.vec3(self.radius, (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point),
                "vector_G": mdc.vec3(self.width, (self.basic_start_point + (self.length / 2)),
                                     self.negative_start_point)
            },
            # bottom side right edge
            "direction_8": {
                "vector_A": mdc.vec3(self.positive_start_point - self.width, self.basic_start_point,
                                     self.negative_start_point),
                "vector_B": mdc.vec3(self.positive_start_point - self.width,
                                     (self.basic_start_point + (self.length / 2)),
                                     self.negative_start_point),
                "vector_C": mdc.vec3(self.positive_start_point - self.radius,
                                     (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point),
                "vector_D": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point),
                "vector_E": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point),
                "vector_F": mdc.vec3(self.positive_start_point - self.radius,
                                     (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point),
                "vector_G": mdc.vec3(self.positive_start_point - self.width,
                                     (self.basic_start_point - (self.length / 2)),
                                     self.negative_start_point)
            },
            # front side top edge
            "direction_9": {
                "vector_A": mdc.vec3(self.basic_start_point, self.negative_start_point,
                                     self.positive_start_point - self.width),
                "vector_B": mdc.vec3((self.basic_start_point + (self.length / 2)), self.negative_start_point,
                                     self.positive_start_point - self.width),
                "vector_C": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point, self.positive_start_point - self.radius),
                "vector_D": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point, self.positive_start_point),
                "vector_E": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point, self.positive_start_point),
                "vector_F": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point, self.positive_start_point - self.radius),
                "vector_G": mdc.vec3((self.basic_start_point - (self.length / 2)), self.negative_start_point,
                                     self.positive_start_point - self.width),
            },
            # front side bottom edge
            "direction_10": {
                "vector_A": mdc.vec3(self.basic_start_point, self.negative_start_point,
                                     self.negative_start_point + self.width),
                "vector_B": mdc.vec3((self.basic_start_point - (self.length / 2)), self.negative_start_point,
                                     self.negative_start_point + self.width),
                "vector_C": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point, self.negative_start_point + self.radius),
                "vector_D": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point, self.negative_start_point),
                "vector_E": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point, self.negative_start_point),
                "vector_F": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point, self.negative_start_point + self.radius),
                "vector_G": mdc.vec3((self.basic_start_point + (self.length / 2)), self.negative_start_point,
                                     self.negative_start_point + self.width)
            },
            # front side left edge
            "direction_11": {
                "vector_A": mdc.vec3(self.negative_start_point, self.negative_start_point + self.width,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.negative_start_point, self.negative_start_point + self.width,
                                     (self.basic_start_point - (self.length / 2)), ),
                "vector_C": mdc.vec3(self.negative_start_point, self.negative_start_point + self.radius,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_D": mdc.vec3(self.negative_start_point, self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_E": mdc.vec3(self.negative_start_point, self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_F": mdc.vec3(self.negative_start_point, self.negative_start_point + self.radius,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_G": mdc.vec3(self.negative_start_point, self.negative_start_point + self.width,
                                     (self.basic_start_point + (self.length / 2)), )
            },
            # front side right edge
            "direction_12": {
                "vector_A": mdc.vec3(self.positive_start_point, self.negative_start_point + self.width,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.positive_start_point, self.negative_start_point + self.width,
                                     (self.basic_start_point + (self.length / 2))),
                "vector_C": mdc.vec3(self.positive_start_point, self.negative_start_point + self.radius,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_D": mdc.vec3(self.positive_start_point, self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_E": mdc.vec3(self.positive_start_point, self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_F": mdc.vec3(self.positive_start_point, self.negative_start_point + self.radius,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_G": mdc.vec3(self.positive_start_point, self.negative_start_point + self.width,
                                     (self.basic_start_point - (self.length / 2)), ),
            },
            # back side top edge
            "direction_13": {
                "vector_A": mdc.vec3(self.basic_start_point, self.positive_start_point,
                                     self.positive_start_point - self.width),
                "vector_B": mdc.vec3((self.basic_start_point - (self.length / 2)), self.positive_start_point,
                                     self.positive_start_point - self.width),
                "vector_C": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point, self.positive_start_point - self.radius),
                "vector_D": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point, self.positive_start_point),
                "vector_E": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point, self.positive_start_point),
                "vector_F": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point, self.positive_start_point - self.radius),
                "vector_G": mdc.vec3((self.basic_start_point + (self.length / 2)), self.positive_start_point,
                                     self.positive_start_point - self.width),
            },
            # back side bottom edge
            "direction_14": {
                "vector_A": mdc.vec3(self.basic_start_point, self.positive_start_point,
                                     self.negative_start_point + self.width),
                "vector_G": mdc.vec3((self.basic_start_point - (self.length / 2)), self.positive_start_point,
                                     self.negative_start_point + self.width),
                "vector_F": mdc.vec3((self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point, self.negative_start_point + self.radius),
                "vector_E": mdc.vec3((self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point, self.negative_start_point),
                "vector_D": mdc.vec3((self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point, self.negative_start_point),
                "vector_C": mdc.vec3((self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point, self.negative_start_point + self.radius),
                "vector_B": mdc.vec3((self.basic_start_point + (self.length / 2)), self.positive_start_point,
                                     self.negative_start_point + self.width)
            },
            # back side left edge
            "direction_15": {
                "vector_A": mdc.vec3(self.negative_start_point, self.positive_start_point - self.width,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.negative_start_point, self.positive_start_point - self.width,
                                     (self.basic_start_point + (self.length / 2))),
                "vector_C": mdc.vec3(self.negative_start_point, self.positive_start_point - self.radius,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_D": mdc.vec3(self.negative_start_point, self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_E": mdc.vec3(self.negative_start_point, self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_F": mdc.vec3(self.negative_start_point, self.positive_start_point - self.radius,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_G": mdc.vec3(self.negative_start_point, self.positive_start_point - self.width,
                                     (self.basic_start_point - (self.length / 2)), ),
            },
            # back side right edge
            "direction_16": {
                "vector_A": mdc.vec3(self.positive_start_point, self.positive_start_point - self.width,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.positive_start_point, self.positive_start_point - self.width,
                                     (self.basic_start_point - (self.length / 2))),
                "vector_C": mdc.vec3(self.positive_start_point, self.positive_start_point - self.radius,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_D": mdc.vec3(self.positive_start_point, self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_E": mdc.vec3(self.positive_start_point, self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_F": mdc.vec3(self.positive_start_point, self.positive_start_point - self.radius,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_G": mdc.vec3(self.positive_start_point, self.positive_start_point - self.width,
                                     (self.basic_start_point + (self.length / 2))),
            },
            # left side top edge
            "direction_17": {
                "vector_A": mdc.vec3(self.negative_start_point, self.basic_start_point,
                                     self.positive_start_point - self.width),
                "vector_B": mdc.vec3(self.negative_start_point, (self.basic_start_point - (self.length / 2)),
                                     self.positive_start_point - self.width),
                "vector_C": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point - self.radius),
                "vector_D": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point),
                "vector_E": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point),
                "vector_F": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point - self.radius),
                "vector_G": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2)),
                                     self.positive_start_point - self.width)
            },
            # left side bottom edge
            "direction_18": {
                "vector_A": mdc.vec3(self.negative_start_point, self.basic_start_point,
                                     self.negative_start_point + self.width),
                "vector_B": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2)),
                                     self.negative_start_point + self.width),
                "vector_C": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point + self.radius),
                "vector_D": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point),
                "vector_E": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point),
                "vector_F": mdc.vec3(self.negative_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point + self.radius),
                "vector_G": mdc.vec3(self.negative_start_point, (self.basic_start_point - (self.length / 2)),
                                     self.negative_start_point + self.width),
            },
            # left side front edge
            "direction_19": {
                "vector_A": mdc.vec3(self.negative_start_point + self.width, self.negative_start_point,
                                     self.basic_start_point),
                "vector_G": mdc.vec3(self.negative_start_point + self.width, self.negative_start_point,
                                     (self.basic_start_point - (self.length / 2)), ),
                "vector_F": mdc.vec3(self.negative_start_point + self.radius, self.negative_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_E": mdc.vec3(self.negative_start_point, self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_D": mdc.vec3(self.negative_start_point, self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_C": mdc.vec3(self.negative_start_point + self.radius, self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_B": mdc.vec3(self.negative_start_point + self.width, self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2)))
            },
            # left side back edge
            "direction_20": {
                "vector_A": mdc.vec3(self.negative_start_point + self.width, self.positive_start_point,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.negative_start_point + self.width, self.positive_start_point,
                                     (self.basic_start_point - (self.length / 2)), ),
                "vector_C": mdc.vec3(self.negative_start_point + self.radius, self.positive_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_D": mdc.vec3(self.negative_start_point, self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_E": mdc.vec3(self.negative_start_point, self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_F": mdc.vec3(self.negative_start_point + self.radius, self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_G": mdc.vec3(self.negative_start_point + self.width, self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2)))
            },
            # right side top edge
            "direction_21": {
                "vector_A": mdc.vec3(self.positive_start_point, self.basic_start_point,
                                     self.positive_start_point - self.width),
                "vector_B": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2)),
                                     self.positive_start_point - self.width),
                "vector_C": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.positive_start_point - self.radius),
                "vector_D": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.positive_start_point),
                "vector_E": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.positive_start_point),
                "vector_F": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.positive_start_point - self.radius),
                "vector_G": mdc.vec3(self.positive_start_point, (self.basic_start_point - (self.length / 2)),
                                     self.positive_start_point - self.width),
            },
            # right side bottom edge
            "direction_22": {
                "vector_A": mdc.vec3(self.positive_start_point, self.basic_start_point,
                                     self.negative_start_point + self.width),
                "vector_B": mdc.vec3(self.positive_start_point, (self.basic_start_point - (self.length / 2)),
                                     self.negative_start_point + self.width),
                "vector_C": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2))),
                                     self.negative_start_point + self.radius),
                "vector_D": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2))),
                                     self.negative_start_point),
                "vector_E": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2)),
                                     self.negative_start_point),
                "vector_F": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius),
                                     self.negative_start_point + self.radius),
                "vector_G": mdc.vec3(self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2)),
                                     self.negative_start_point + self.width)
            },
            # right side front edge
            "direction_23": {
                "vector_A": mdc.vec3(self.positive_start_point - self.width, self.negative_start_point,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.positive_start_point - self.width, self.negative_start_point,
                                     (self.basic_start_point - (self.length / 2)), ),
                "vector_C": mdc.vec3(self.positive_start_point - self.radius, self.negative_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_D": mdc.vec3(self.positive_start_point, self.negative_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_E": mdc.vec3(self.positive_start_point, self.negative_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_F": mdc.vec3(self.positive_start_point - self.radius, self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_G": mdc.vec3(self.positive_start_point - self.width, self.negative_start_point,
                                     (self.basic_start_point + (self.length / 2)))
            },
            # rights side back edge
            "direction_24": {
                "vector_A": mdc.vec3(self.positive_start_point - self.width, self.positive_start_point,
                                     self.basic_start_point),
                "vector_B": mdc.vec3(self.positive_start_point - self.width, self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2))),
                "vector_C": mdc.vec3(self.positive_start_point - self.radius, self.positive_start_point,
                                     (self.basic_start_point + (self.length / 2) + self.radius)),
                "vector_D": mdc.vec3(self.positive_start_point, self.positive_start_point,
                                     (self.basic_start_point + self.width + (self.length / 2))),
                "vector_E": mdc.vec3(self.positive_start_point, self.positive_start_point,
                                     (self.basic_start_point - (self.width + (self.length / 2)))),
                "vector_F": mdc.vec3(self.positive_start_point - self.radius, self.positive_start_point,
                                     (self.basic_start_point - (self.radius + (self.length / 2)))),
                "vector_G": mdc.vec3(self.positive_start_point - self.width, self.positive_start_point,
                                     (self.basic_start_point - (self.length / 2)))
            },
        }

        self.dept = {
            "direction_1": -self.depth * mdc.Z,
            "direction_2": -self.depth * mdc.Z,
            "direction_3": -self.depth * mdc.Z,
            "direction_4": -self.depth * mdc.Z,
            "direction_5": self.depth * mdc.Z,
            "direction_6": self.depth * mdc.Z,
            "direction_7": self.depth * mdc.Z,
            "direction_8": self.depth * mdc.Z,
            "direction_9": self.depth * mdc.Y,
            "direction_10": self.depth * mdc.Y,
            "direction_11": self.depth * mdc.X,
            "direction_12": -self.depth * mdc.X,
            "direction_13": -self.depth * mdc.Y,
            "direction_14": -self.depth * mdc.Y,
            "direction_15": self.depth * mdc.X,
            "direction_16": - self.depth * mdc.X,
            "direction_17": self.depth * mdc.X,
            "direction_18": self.depth * mdc.X,
            "direction_19": self.depth * mdc.Y,
            "direction_20": -self.depth * mdc.Y,
            "direction_21": -self.depth * mdc.X,
            "direction_22": -self.depth * mdc.X,
            "direction_23": self.depth * mdc.Y,
            "direction_24": -self.depth * mdc.Y,

        }

    def transformation(self):
        _horizontal_circular_end_blind_slot_primitive = [mdc.Segment(self.circular_vectors[self.dir]["vector_A"],
                                                                     self.circular_vectors[self.dir]["vector_B"]),
                                                         mdc.ArcThrough(self.circular_vectors[self.dir]["vector_B"],
                                                                        self.circular_vectors[self.dir]["vector_C"],
                                                                        self.circular_vectors[self.dir]["vector_D"]),
                                                         mdc.Segment(self.circular_vectors[self.dir]["vector_D"],
                                                                     self.circular_vectors[self.dir]["vector_E"]),
                                                         mdc.ArcThrough(self.circular_vectors[self.dir]["vector_E"],
                                                                        self.circular_vectors[self.dir]["vector_F"],
                                                                        self.circular_vectors[self.dir]["vector_G"]),
                                                         mdc.Segment(self.circular_vectors[self.dir]["vector_G"],
                                                                     self.circular_vectors[self.dir]["vector_A"])],

        _horizontal_circular_end_blind_slot = mdc.extrusion(self.dept[self.dir],
                                                            mdc.flatsurface(
                                                                _horizontal_circular_end_blind_slot_primitive))

        return _horizontal_circular_end_blind_slot
